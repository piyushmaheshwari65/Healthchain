// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.6.12;

contract Healthchain{
    
    address admin;
    enum Status{
        Active,
        Pending,
        Expired,
        Revoked
    }
    
    enum coveredByInsurance{
        
        Diarrhea,
        Malaria,
        AccidentRelated,
        Cataract
    }
    
    struct userDetails{
        bytes32 id; //unique id generated by contract
        string name;
        address usrAddress;
        uint expiryDate;
        uint premiumAmount;
        uint insuranceAmount;
        uint currentInsuranceAmount;
        mapping(coveredByInsurance=>bool) treatmentCovered;
        Status status;
    }
    
    mapping(bytes32 => userDetails) userInsuranceDetails;
    
    //Only admin is allowed to access the function
    modifier onlyAdmin{
        require(admin == msg.sender,"Admin Access Only");
        _;
    }
    
    //Only user is allowed to access the function
    modifier onlyUser(bytes32 _id){
        require(userInsuranceDetails[_id].usrAddress == msg.sender,"User Access Only");
        _;
    }
    
    //Checks if the amount paid by user is equal to the prmium amount
    modifier validPremium(bytes32 _id){
        require(userInsuranceDetails[_id].premiumAmount==msg.value,"Amount Does not match with premium");
        _;
    }
    
    //Checks if the diisease diagnosd is covered by insurance
    modifier isTreatmentCoveredByInsurance(bytes32 _id,uint _diagnosis){
        require(userInsuranceDetails[_id].treatmentCovered[coveredByInsurance(_diagnosis)]==true,"Disease not covered by Insurance");
        _;
    }
    
    //Checks if the insurance amount available for the user is not null
    modifier isInsuranceAmountNotNull(bytes32 _id){
        require(userInsuranceDetails[_id].currentInsuranceAmount>0,"Insurance amount is 0");
        _;
    }
    
    //Checks if the insurance status is Active
    modifier isStatusActive(bytes32 _id){
        require(userInsuranceDetails[_id].status==Status.Active,"Status Not Active");
        _;
    }
    
    //checks if the insurance validity is expired or not
    modifier checkExpiryDate(bytes32 _id){
        if(block.timestamp > userInsuranceDetails[_id].expiryDate &&  userInsuranceDetails[_id].status != Status.Expired){
           // userInsuranceDetails[_id].status=Status.Expired;
            revert("Insurance Expired");
        }
        else{
            _;
        }
    }
    constructor() public{
       admin = msg.sender;
    }
    
    mapping(address=>bytes32) idAddrMap;
    
    //creates new user 
    function addUser(string memory _name, address _usrAddr, uint _premiumAmount, uint _insuranceAmount, uint[] calldata _diagnosis ) external  onlyAdmin{
        bytes32 _id = keccak256(abi.encodePacked(_usrAddr,msg.sender));
       
        userInsuranceDetails[_id].id=_id;
        userInsuranceDetails[_id].name=_name;
        userInsuranceDetails[_id].usrAddress=_usrAddr;
        userInsuranceDetails[_id].premiumAmount=_premiumAmount;
        userInsuranceDetails[_id].insuranceAmount=_insuranceAmount;
        userInsuranceDetails[_id].status = Status.Pending;
        userInsuranceDetails[_id].currentInsuranceAmount=0;
        for(uint i=0;i<_diagnosis.length;i++){
            userInsuranceDetails[_id].treatmentCovered[coveredByInsurance(_diagnosis[i])]=true;
        }
        idAddrMap[_usrAddr] = _id;
    }
    
    function getID() external view returns(bytes32){
        return idAddrMap[msg.sender];
    }
    

    
    //fetched user details
    function getUserInsuranceDetails(bytes32 _id)external view returns(bytes32,string memory,address, uint,uint,uint,Status){
        return(userInsuranceDetails[_id].id,userInsuranceDetails[_id].name,userInsuranceDetails[_id].usrAddress,userInsuranceDetails[_id].expiryDate,userInsuranceDetails[_id].insuranceAmount,userInsuranceDetails[_id].currentInsuranceAmount,userInsuranceDetails[_id].status);
        
    }
    
    //user pays the premium
    function payPremium(bytes32 _id) payable public onlyUser(_id) validPremium(_id) {
        userInsuranceDetails[_id].status=Status.Active;
        userInsuranceDetails[_id].currentInsuranceAmount=userInsuranceDetails[_id].insuranceAmount;
        userInsuranceDetails[_id].expiryDate = block.timestamp * 365 days;
    }

    //Calculates the amount paid by the insurance agency
    function calculateAmountPaidByInsurance(bytes32 _id, uint _diagnosis, uint _amount) public view
        isTreatmentCoveredByInsurance(_id, _diagnosis) isInsuranceAmountNotNull(_id) isStatusActive(_id) checkExpiryDate(_id) returns(uint){
        uint _amountPayable = _amount*80/100;
        if(_amountPayable>userInsuranceDetails[_id].currentInsuranceAmount){
            _amountPayable = userInsuranceDetails[_id].currentInsuranceAmount;
        }
        return _amountPayable;
    }
    
    //Revoking user Insurance 
    function revokeInsurance(bytes32 _id) external onlyAdmin{
        userInsuranceDetails[_id].status = Status.Revoked;
    }
    
    //Function where Hospital can claim the insurance amount
    function claimInsurance(bytes32 _id, uint _diagnosis, uint _amount ) payable public 
        isTreatmentCoveredByInsurance(_id, _diagnosis) isInsuranceAmountNotNull(_id) isStatusActive(_id) checkExpiryDate(_id) returns(uint){
        uint amountToBePaid = calculateAmountPaidByInsurance(_id,_diagnosis,_amount);
        userInsuranceDetails[_id].currentInsuranceAmount-=amountToBePaid;
        msg.sender.transfer(amountToBePaid);
        return amountToBePaid;
    } 
    
    //insurance agency can deposit money    
    function depositFunds() public payable onlyAdmin{
    
    }
    
   /* function verifyPremium(bytes32 _id, uint _diagnosis) public view returns(bool){
        if(userInsuranceDetails[_id].treatmentCovered[coveredByInsurance(_diagnosis)]==true){
            return true;
        }
        return false;
    }*/
    
}
